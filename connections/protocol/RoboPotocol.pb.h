// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: RoboIDE2/mur-ide/connections/protocol/RoboPotocol.proto

#ifndef PROTOBUF_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto__INCLUDED
#define PROTOBUF_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace RoboProtocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();
void protobuf_AssignDesc_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();
void protobuf_ShutdownFile_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();

class Command;
class BinaryPreamble;
class BinaryChunk;
class BinaryEnd;
class ChangeName;
class ChangePassword;
class SendBluetoothMAC;
class StatusInfoRequest;
class StatusInfo;
class Result;

enum Command_Value {
  Command_Value_RUN = 0,
  Command_Value_KILL = 1
};
bool Command_Value_IsValid(int value);
const Command_Value Command_Value_Value_MIN = Command_Value_RUN;
const Command_Value Command_Value_Value_MAX = Command_Value_KILL;
const int Command_Value_Value_ARRAYSIZE = Command_Value_Value_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_Value_descriptor();
inline const ::std::string& Command_Value_Name(Command_Value value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_Value_descriptor(), value);
}
inline bool Command_Value_Parse(
    const ::std::string& name, Command_Value* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_Value>(
    Command_Value_descriptor(), name, value);
}
enum Result_Value {
  Result_Value_SUCCESS = 1,
  Result_Value_ERROR = 2
};
bool Result_Value_IsValid(int value);
const Result_Value Result_Value_Value_MIN = Result_Value_SUCCESS;
const Result_Value Result_Value_Value_MAX = Result_Value_ERROR;
const int Result_Value_Value_ARRAYSIZE = Result_Value_Value_MAX + 1;

const ::google::protobuf::EnumDescriptor* Result_Value_descriptor();
inline const ::std::string& Result_Value_Name(Result_Value value) {
  return ::google::protobuf::internal::NameOfEnum(
    Result_Value_descriptor(), value);
}
inline bool Result_Value_Parse(
    const ::std::string& name, Result_Value* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Result_Value>(
    Result_Value_descriptor(), name, value);
}
// ===================================================================

class Command : public ::google::protobuf::Message {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  void Swap(Command* other);

  // implements Message ----------------------------------------------

  Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Command_Value Value;
  static const Value RUN = Command_Value_RUN;
  static const Value KILL = Command_Value_KILL;
  static inline bool Value_IsValid(int value) {
    return Command_Value_IsValid(value);
  }
  static const Value Value_MIN =
    Command_Value_Value_MIN;
  static const Value Value_MAX =
    Command_Value_Value_MAX;
  static const int Value_ARRAYSIZE =
    Command_Value_Value_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Value_descriptor() {
    return Command_Value_descriptor();
  }
  static inline const ::std::string& Value_Name(Value value) {
    return Command_Value_Name(value);
  }
  static inline bool Value_Parse(const ::std::string& name,
      Value* value) {
    return Command_Value_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:RoboProtocol.Command)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();
  friend void protobuf_AssignDesc_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();
  friend void protobuf_ShutdownFile_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();

  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// -------------------------------------------------------------------

class BinaryPreamble : public ::google::protobuf::Message {
 public:
  BinaryPreamble();
  virtual ~BinaryPreamble();

  BinaryPreamble(const BinaryPreamble& from);

  inline BinaryPreamble& operator=(const BinaryPreamble& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BinaryPreamble& default_instance();

  void Swap(BinaryPreamble* other);

  // implements Message ----------------------------------------------

  BinaryPreamble* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BinaryPreamble& from);
  void MergeFrom(const BinaryPreamble& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint32 binarySize = 2;
  inline bool has_binarysize() const;
  inline void clear_binarysize();
  static const int kBinarySizeFieldNumber = 2;
  inline ::google::protobuf::uint32 binarysize() const;
  inline void set_binarysize(::google::protobuf::uint32 value);

  // required uint32 chunkSize = 3;
  inline bool has_chunksize() const;
  inline void clear_chunksize();
  static const int kChunkSizeFieldNumber = 3;
  inline ::google::protobuf::uint32 chunksize() const;
  inline void set_chunksize(::google::protobuf::uint32 value);

  // required uint32 binaryCRC = 4;
  inline bool has_binarycrc() const;
  inline void clear_binarycrc();
  static const int kBinaryCRCFieldNumber = 4;
  inline ::google::protobuf::uint32 binarycrc() const;
  inline void set_binarycrc(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RoboProtocol.BinaryPreamble)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_binarysize();
  inline void clear_has_binarysize();
  inline void set_has_chunksize();
  inline void clear_has_chunksize();
  inline void set_has_binarycrc();
  inline void clear_has_binarycrc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::uint32 binarysize_;
  ::google::protobuf::uint32 chunksize_;
  ::google::protobuf::uint32 binarycrc_;
  friend void  protobuf_AddDesc_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();
  friend void protobuf_AssignDesc_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();
  friend void protobuf_ShutdownFile_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();

  void InitAsDefaultInstance();
  static BinaryPreamble* default_instance_;
};
// -------------------------------------------------------------------

class BinaryChunk : public ::google::protobuf::Message {
 public:
  BinaryChunk();
  virtual ~BinaryChunk();

  BinaryChunk(const BinaryChunk& from);

  inline BinaryChunk& operator=(const BinaryChunk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BinaryChunk& default_instance();

  void Swap(BinaryChunk* other);

  // implements Message ----------------------------------------------

  BinaryChunk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BinaryChunk& from);
  void MergeFrom(const BinaryChunk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 chunkNumber = 1;
  inline bool has_chunknumber() const;
  inline void clear_chunknumber();
  static const int kChunkNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 chunknumber() const;
  inline void set_chunknumber(::google::protobuf::uint32 value);

  // required bytes chunk = 2;
  inline bool has_chunk() const;
  inline void clear_chunk();
  static const int kChunkFieldNumber = 2;
  inline const ::std::string& chunk() const;
  inline void set_chunk(const ::std::string& value);
  inline void set_chunk(const char* value);
  inline void set_chunk(const void* value, size_t size);
  inline ::std::string* mutable_chunk();
  inline ::std::string* release_chunk();
  inline void set_allocated_chunk(::std::string* chunk);

  // @@protoc_insertion_point(class_scope:RoboProtocol.BinaryChunk)
 private:
  inline void set_has_chunknumber();
  inline void clear_has_chunknumber();
  inline void set_has_chunk();
  inline void clear_has_chunk();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* chunk_;
  ::google::protobuf::uint32 chunknumber_;
  friend void  protobuf_AddDesc_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();
  friend void protobuf_AssignDesc_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();
  friend void protobuf_ShutdownFile_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();

  void InitAsDefaultInstance();
  static BinaryChunk* default_instance_;
};
// -------------------------------------------------------------------

class BinaryEnd : public ::google::protobuf::Message {
 public:
  BinaryEnd();
  virtual ~BinaryEnd();

  BinaryEnd(const BinaryEnd& from);

  inline BinaryEnd& operator=(const BinaryEnd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BinaryEnd& default_instance();

  void Swap(BinaryEnd* other);

  // implements Message ----------------------------------------------

  BinaryEnd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BinaryEnd& from);
  void MergeFrom(const BinaryEnd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:RoboProtocol.BinaryEnd)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();
  friend void protobuf_AssignDesc_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();
  friend void protobuf_ShutdownFile_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();

  void InitAsDefaultInstance();
  static BinaryEnd* default_instance_;
};
// -------------------------------------------------------------------

class ChangeName : public ::google::protobuf::Message {
 public:
  ChangeName();
  virtual ~ChangeName();

  ChangeName(const ChangeName& from);

  inline ChangeName& operator=(const ChangeName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeName& default_instance();

  void Swap(ChangeName* other);

  // implements Message ----------------------------------------------

  ChangeName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeName& from);
  void MergeFrom(const ChangeName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:RoboProtocol.ChangeName)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  friend void  protobuf_AddDesc_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();
  friend void protobuf_AssignDesc_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();
  friend void protobuf_ShutdownFile_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();

  void InitAsDefaultInstance();
  static ChangeName* default_instance_;
};
// -------------------------------------------------------------------

class ChangePassword : public ::google::protobuf::Message {
 public:
  ChangePassword();
  virtual ~ChangePassword();

  ChangePassword(const ChangePassword& from);

  inline ChangePassword& operator=(const ChangePassword& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangePassword& default_instance();

  void Swap(ChangePassword* other);

  // implements Message ----------------------------------------------

  ChangePassword* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangePassword& from);
  void MergeFrom(const ChangePassword& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string password = 1;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 1;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:RoboProtocol.ChangePassword)
 private:
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* password_;
  friend void  protobuf_AddDesc_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();
  friend void protobuf_AssignDesc_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();
  friend void protobuf_ShutdownFile_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();

  void InitAsDefaultInstance();
  static ChangePassword* default_instance_;
};
// -------------------------------------------------------------------

class SendBluetoothMAC : public ::google::protobuf::Message {
 public:
  SendBluetoothMAC();
  virtual ~SendBluetoothMAC();

  SendBluetoothMAC(const SendBluetoothMAC& from);

  inline SendBluetoothMAC& operator=(const SendBluetoothMAC& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendBluetoothMAC& default_instance();

  void Swap(SendBluetoothMAC* other);

  // implements Message ----------------------------------------------

  SendBluetoothMAC* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendBluetoothMAC& from);
  void MergeFrom(const SendBluetoothMAC& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string bluetoothMAC = 1;
  inline bool has_bluetoothmac() const;
  inline void clear_bluetoothmac();
  static const int kBluetoothMACFieldNumber = 1;
  inline const ::std::string& bluetoothmac() const;
  inline void set_bluetoothmac(const ::std::string& value);
  inline void set_bluetoothmac(const char* value);
  inline void set_bluetoothmac(const char* value, size_t size);
  inline ::std::string* mutable_bluetoothmac();
  inline ::std::string* release_bluetoothmac();
  inline void set_allocated_bluetoothmac(::std::string* bluetoothmac);

  // @@protoc_insertion_point(class_scope:RoboProtocol.SendBluetoothMAC)
 private:
  inline void set_has_bluetoothmac();
  inline void clear_has_bluetoothmac();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bluetoothmac_;
  friend void  protobuf_AddDesc_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();
  friend void protobuf_AssignDesc_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();
  friend void protobuf_ShutdownFile_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();

  void InitAsDefaultInstance();
  static SendBluetoothMAC* default_instance_;
};
// -------------------------------------------------------------------

class StatusInfoRequest : public ::google::protobuf::Message {
 public:
  StatusInfoRequest();
  virtual ~StatusInfoRequest();

  StatusInfoRequest(const StatusInfoRequest& from);

  inline StatusInfoRequest& operator=(const StatusInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusInfoRequest& default_instance();

  void Swap(StatusInfoRequest* other);

  // implements Message ----------------------------------------------

  StatusInfoRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusInfoRequest& from);
  void MergeFrom(const StatusInfoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:RoboProtocol.StatusInfoRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();
  friend void protobuf_AssignDesc_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();
  friend void protobuf_ShutdownFile_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();

  void InitAsDefaultInstance();
  static StatusInfoRequest* default_instance_;
};
// -------------------------------------------------------------------

class StatusInfo : public ::google::protobuf::Message {
 public:
  StatusInfo();
  virtual ~StatusInfo();

  StatusInfo(const StatusInfo& from);

  inline StatusInfo& operator=(const StatusInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusInfo& default_instance();

  void Swap(StatusInfo* other);

  // implements Message ----------------------------------------------

  StatusInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusInfo& from);
  void MergeFrom(const StatusInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 deviceNum = 1;
  inline bool has_devicenum() const;
  inline void clear_devicenum();
  static const int kDeviceNumFieldNumber = 1;
  inline ::google::protobuf::uint32 devicenum() const;
  inline void set_devicenum(::google::protobuf::uint32 value);

  // required bytes Devices = 2;
  inline bool has_devices() const;
  inline void clear_devices();
  static const int kDevicesFieldNumber = 2;
  inline const ::std::string& devices() const;
  inline void set_devices(const ::std::string& value);
  inline void set_devices(const char* value);
  inline void set_devices(const void* value, size_t size);
  inline ::std::string* mutable_devices();
  inline ::std::string* release_devices();
  inline void set_allocated_devices(::std::string* devices);

  // required float yaw = 3;
  inline bool has_yaw() const;
  inline void clear_yaw();
  static const int kYawFieldNumber = 3;
  inline float yaw() const;
  inline void set_yaw(float value);

  // required float pitch = 4;
  inline bool has_pitch() const;
  inline void clear_pitch();
  static const int kPitchFieldNumber = 4;
  inline float pitch() const;
  inline void set_pitch(float value);

  // required float roll = 5;
  inline bool has_roll() const;
  inline void clear_roll();
  static const int kRollFieldNumber = 5;
  inline float roll() const;
  inline void set_roll(float value);

  // required float depth = 6;
  inline bool has_depth() const;
  inline void clear_depth();
  static const int kDepthFieldNumber = 6;
  inline float depth() const;
  inline void set_depth(float value);

  // required uint32 leak = 7;
  inline bool has_leak() const;
  inline void clear_leak();
  static const int kLeakFieldNumber = 7;
  inline ::google::protobuf::uint32 leak() const;
  inline void set_leak(::google::protobuf::uint32 value);

  // required uint32 version = 8;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 8;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // required uint32 cameras = 9;
  inline bool has_cameras() const;
  inline void clear_cameras();
  static const int kCamerasFieldNumber = 9;
  inline ::google::protobuf::uint32 cameras() const;
  inline void set_cameras(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RoboProtocol.StatusInfo)
 private:
  inline void set_has_devicenum();
  inline void clear_has_devicenum();
  inline void set_has_devices();
  inline void clear_has_devices();
  inline void set_has_yaw();
  inline void clear_has_yaw();
  inline void set_has_pitch();
  inline void clear_has_pitch();
  inline void set_has_roll();
  inline void clear_has_roll();
  inline void set_has_depth();
  inline void clear_has_depth();
  inline void set_has_leak();
  inline void clear_has_leak();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_cameras();
  inline void clear_has_cameras();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* devices_;
  ::google::protobuf::uint32 devicenum_;
  float yaw_;
  float pitch_;
  float roll_;
  float depth_;
  ::google::protobuf::uint32 leak_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 cameras_;
  friend void  protobuf_AddDesc_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();
  friend void protobuf_AssignDesc_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();
  friend void protobuf_ShutdownFile_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();

  void InitAsDefaultInstance();
  static StatusInfo* default_instance_;
};
// -------------------------------------------------------------------

class Result : public ::google::protobuf::Message {
 public:
  Result();
  virtual ~Result();

  Result(const Result& from);

  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Result& default_instance();

  void Swap(Result* other);

  // implements Message ----------------------------------------------

  Result* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Result& from);
  void MergeFrom(const Result& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Result_Value Value;
  static const Value SUCCESS = Result_Value_SUCCESS;
  static const Value ERROR = Result_Value_ERROR;
  static inline bool Value_IsValid(int value) {
    return Result_Value_IsValid(value);
  }
  static const Value Value_MIN =
    Result_Value_Value_MIN;
  static const Value Value_MAX =
    Result_Value_Value_MAX;
  static const int Value_ARRAYSIZE =
    Result_Value_Value_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Value_descriptor() {
    return Result_Value_descriptor();
  }
  static inline const ::std::string& Value_Name(Value value) {
    return Result_Value_Name(value);
  }
  static inline bool Value_Parse(const ::std::string& name,
      Value* value) {
    return Result_Value_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:RoboProtocol.Result)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();
  friend void protobuf_AssignDesc_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();
  friend void protobuf_ShutdownFile_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto();

  void InitAsDefaultInstance();
  static Result* default_instance_;
};
// ===================================================================


// ===================================================================

// Command

// -------------------------------------------------------------------

// BinaryPreamble

// required string name = 1;
inline bool BinaryPreamble::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BinaryPreamble::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BinaryPreamble::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BinaryPreamble::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& BinaryPreamble::name() const {
  // @@protoc_insertion_point(field_get:RoboProtocol.BinaryPreamble.name)
  return *name_;
}
inline void BinaryPreamble::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:RoboProtocol.BinaryPreamble.name)
}
inline void BinaryPreamble::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:RoboProtocol.BinaryPreamble.name)
}
inline void BinaryPreamble::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RoboProtocol.BinaryPreamble.name)
}
inline ::std::string* BinaryPreamble::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RoboProtocol.BinaryPreamble.name)
  return name_;
}
inline ::std::string* BinaryPreamble::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BinaryPreamble::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RoboProtocol.BinaryPreamble.name)
}

// required uint32 binarySize = 2;
inline bool BinaryPreamble::has_binarysize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BinaryPreamble::set_has_binarysize() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BinaryPreamble::clear_has_binarysize() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BinaryPreamble::clear_binarysize() {
  binarysize_ = 0u;
  clear_has_binarysize();
}
inline ::google::protobuf::uint32 BinaryPreamble::binarysize() const {
  // @@protoc_insertion_point(field_get:RoboProtocol.BinaryPreamble.binarySize)
  return binarysize_;
}
inline void BinaryPreamble::set_binarysize(::google::protobuf::uint32 value) {
  set_has_binarysize();
  binarysize_ = value;
  // @@protoc_insertion_point(field_set:RoboProtocol.BinaryPreamble.binarySize)
}

// required uint32 chunkSize = 3;
inline bool BinaryPreamble::has_chunksize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BinaryPreamble::set_has_chunksize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BinaryPreamble::clear_has_chunksize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BinaryPreamble::clear_chunksize() {
  chunksize_ = 0u;
  clear_has_chunksize();
}
inline ::google::protobuf::uint32 BinaryPreamble::chunksize() const {
  // @@protoc_insertion_point(field_get:RoboProtocol.BinaryPreamble.chunkSize)
  return chunksize_;
}
inline void BinaryPreamble::set_chunksize(::google::protobuf::uint32 value) {
  set_has_chunksize();
  chunksize_ = value;
  // @@protoc_insertion_point(field_set:RoboProtocol.BinaryPreamble.chunkSize)
}

// required uint32 binaryCRC = 4;
inline bool BinaryPreamble::has_binarycrc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BinaryPreamble::set_has_binarycrc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BinaryPreamble::clear_has_binarycrc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BinaryPreamble::clear_binarycrc() {
  binarycrc_ = 0u;
  clear_has_binarycrc();
}
inline ::google::protobuf::uint32 BinaryPreamble::binarycrc() const {
  // @@protoc_insertion_point(field_get:RoboProtocol.BinaryPreamble.binaryCRC)
  return binarycrc_;
}
inline void BinaryPreamble::set_binarycrc(::google::protobuf::uint32 value) {
  set_has_binarycrc();
  binarycrc_ = value;
  // @@protoc_insertion_point(field_set:RoboProtocol.BinaryPreamble.binaryCRC)
}

// -------------------------------------------------------------------

// BinaryChunk

// required uint32 chunkNumber = 1;
inline bool BinaryChunk::has_chunknumber() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BinaryChunk::set_has_chunknumber() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BinaryChunk::clear_has_chunknumber() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BinaryChunk::clear_chunknumber() {
  chunknumber_ = 0u;
  clear_has_chunknumber();
}
inline ::google::protobuf::uint32 BinaryChunk::chunknumber() const {
  // @@protoc_insertion_point(field_get:RoboProtocol.BinaryChunk.chunkNumber)
  return chunknumber_;
}
inline void BinaryChunk::set_chunknumber(::google::protobuf::uint32 value) {
  set_has_chunknumber();
  chunknumber_ = value;
  // @@protoc_insertion_point(field_set:RoboProtocol.BinaryChunk.chunkNumber)
}

// required bytes chunk = 2;
inline bool BinaryChunk::has_chunk() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BinaryChunk::set_has_chunk() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BinaryChunk::clear_has_chunk() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BinaryChunk::clear_chunk() {
  if (chunk_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chunk_->clear();
  }
  clear_has_chunk();
}
inline const ::std::string& BinaryChunk::chunk() const {
  // @@protoc_insertion_point(field_get:RoboProtocol.BinaryChunk.chunk)
  return *chunk_;
}
inline void BinaryChunk::set_chunk(const ::std::string& value) {
  set_has_chunk();
  if (chunk_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chunk_ = new ::std::string;
  }
  chunk_->assign(value);
  // @@protoc_insertion_point(field_set:RoboProtocol.BinaryChunk.chunk)
}
inline void BinaryChunk::set_chunk(const char* value) {
  set_has_chunk();
  if (chunk_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chunk_ = new ::std::string;
  }
  chunk_->assign(value);
  // @@protoc_insertion_point(field_set_char:RoboProtocol.BinaryChunk.chunk)
}
inline void BinaryChunk::set_chunk(const void* value, size_t size) {
  set_has_chunk();
  if (chunk_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chunk_ = new ::std::string;
  }
  chunk_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RoboProtocol.BinaryChunk.chunk)
}
inline ::std::string* BinaryChunk::mutable_chunk() {
  set_has_chunk();
  if (chunk_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chunk_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RoboProtocol.BinaryChunk.chunk)
  return chunk_;
}
inline ::std::string* BinaryChunk::release_chunk() {
  clear_has_chunk();
  if (chunk_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = chunk_;
    chunk_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BinaryChunk::set_allocated_chunk(::std::string* chunk) {
  if (chunk_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete chunk_;
  }
  if (chunk) {
    set_has_chunk();
    chunk_ = chunk;
  } else {
    clear_has_chunk();
    chunk_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RoboProtocol.BinaryChunk.chunk)
}

// -------------------------------------------------------------------

// BinaryEnd

// -------------------------------------------------------------------

// ChangeName

// required string name = 1;
inline bool ChangeName::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeName::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeName::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeName::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ChangeName::name() const {
  // @@protoc_insertion_point(field_get:RoboProtocol.ChangeName.name)
  return *name_;
}
inline void ChangeName::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:RoboProtocol.ChangeName.name)
}
inline void ChangeName::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:RoboProtocol.ChangeName.name)
}
inline void ChangeName::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RoboProtocol.ChangeName.name)
}
inline ::std::string* ChangeName::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RoboProtocol.ChangeName.name)
  return name_;
}
inline ::std::string* ChangeName::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChangeName::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RoboProtocol.ChangeName.name)
}

// -------------------------------------------------------------------

// ChangePassword

// required string password = 1;
inline bool ChangePassword::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangePassword::set_has_password() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangePassword::clear_has_password() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangePassword::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& ChangePassword::password() const {
  // @@protoc_insertion_point(field_get:RoboProtocol.ChangePassword.password)
  return *password_;
}
inline void ChangePassword::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:RoboProtocol.ChangePassword.password)
}
inline void ChangePassword::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:RoboProtocol.ChangePassword.password)
}
inline void ChangePassword::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RoboProtocol.ChangePassword.password)
}
inline ::std::string* ChangePassword::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RoboProtocol.ChangePassword.password)
  return password_;
}
inline ::std::string* ChangePassword::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChangePassword::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RoboProtocol.ChangePassword.password)
}

// -------------------------------------------------------------------

// SendBluetoothMAC

// required string bluetoothMAC = 1;
inline bool SendBluetoothMAC::has_bluetoothmac() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendBluetoothMAC::set_has_bluetoothmac() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendBluetoothMAC::clear_has_bluetoothmac() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendBluetoothMAC::clear_bluetoothmac() {
  if (bluetoothmac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bluetoothmac_->clear();
  }
  clear_has_bluetoothmac();
}
inline const ::std::string& SendBluetoothMAC::bluetoothmac() const {
  // @@protoc_insertion_point(field_get:RoboProtocol.SendBluetoothMAC.bluetoothMAC)
  return *bluetoothmac_;
}
inline void SendBluetoothMAC::set_bluetoothmac(const ::std::string& value) {
  set_has_bluetoothmac();
  if (bluetoothmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bluetoothmac_ = new ::std::string;
  }
  bluetoothmac_->assign(value);
  // @@protoc_insertion_point(field_set:RoboProtocol.SendBluetoothMAC.bluetoothMAC)
}
inline void SendBluetoothMAC::set_bluetoothmac(const char* value) {
  set_has_bluetoothmac();
  if (bluetoothmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bluetoothmac_ = new ::std::string;
  }
  bluetoothmac_->assign(value);
  // @@protoc_insertion_point(field_set_char:RoboProtocol.SendBluetoothMAC.bluetoothMAC)
}
inline void SendBluetoothMAC::set_bluetoothmac(const char* value, size_t size) {
  set_has_bluetoothmac();
  if (bluetoothmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bluetoothmac_ = new ::std::string;
  }
  bluetoothmac_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RoboProtocol.SendBluetoothMAC.bluetoothMAC)
}
inline ::std::string* SendBluetoothMAC::mutable_bluetoothmac() {
  set_has_bluetoothmac();
  if (bluetoothmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bluetoothmac_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RoboProtocol.SendBluetoothMAC.bluetoothMAC)
  return bluetoothmac_;
}
inline ::std::string* SendBluetoothMAC::release_bluetoothmac() {
  clear_has_bluetoothmac();
  if (bluetoothmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bluetoothmac_;
    bluetoothmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendBluetoothMAC::set_allocated_bluetoothmac(::std::string* bluetoothmac) {
  if (bluetoothmac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bluetoothmac_;
  }
  if (bluetoothmac) {
    set_has_bluetoothmac();
    bluetoothmac_ = bluetoothmac;
  } else {
    clear_has_bluetoothmac();
    bluetoothmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RoboProtocol.SendBluetoothMAC.bluetoothMAC)
}

// -------------------------------------------------------------------

// StatusInfoRequest

// -------------------------------------------------------------------

// StatusInfo

// required uint32 deviceNum = 1;
inline bool StatusInfo::has_devicenum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatusInfo::set_has_devicenum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatusInfo::clear_has_devicenum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatusInfo::clear_devicenum() {
  devicenum_ = 0u;
  clear_has_devicenum();
}
inline ::google::protobuf::uint32 StatusInfo::devicenum() const {
  // @@protoc_insertion_point(field_get:RoboProtocol.StatusInfo.deviceNum)
  return devicenum_;
}
inline void StatusInfo::set_devicenum(::google::protobuf::uint32 value) {
  set_has_devicenum();
  devicenum_ = value;
  // @@protoc_insertion_point(field_set:RoboProtocol.StatusInfo.deviceNum)
}

// required bytes Devices = 2;
inline bool StatusInfo::has_devices() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StatusInfo::set_has_devices() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StatusInfo::clear_has_devices() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StatusInfo::clear_devices() {
  if (devices_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    devices_->clear();
  }
  clear_has_devices();
}
inline const ::std::string& StatusInfo::devices() const {
  // @@protoc_insertion_point(field_get:RoboProtocol.StatusInfo.Devices)
  return *devices_;
}
inline void StatusInfo::set_devices(const ::std::string& value) {
  set_has_devices();
  if (devices_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    devices_ = new ::std::string;
  }
  devices_->assign(value);
  // @@protoc_insertion_point(field_set:RoboProtocol.StatusInfo.Devices)
}
inline void StatusInfo::set_devices(const char* value) {
  set_has_devices();
  if (devices_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    devices_ = new ::std::string;
  }
  devices_->assign(value);
  // @@protoc_insertion_point(field_set_char:RoboProtocol.StatusInfo.Devices)
}
inline void StatusInfo::set_devices(const void* value, size_t size) {
  set_has_devices();
  if (devices_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    devices_ = new ::std::string;
  }
  devices_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RoboProtocol.StatusInfo.Devices)
}
inline ::std::string* StatusInfo::mutable_devices() {
  set_has_devices();
  if (devices_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    devices_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RoboProtocol.StatusInfo.Devices)
  return devices_;
}
inline ::std::string* StatusInfo::release_devices() {
  clear_has_devices();
  if (devices_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = devices_;
    devices_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StatusInfo::set_allocated_devices(::std::string* devices) {
  if (devices_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete devices_;
  }
  if (devices) {
    set_has_devices();
    devices_ = devices;
  } else {
    clear_has_devices();
    devices_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RoboProtocol.StatusInfo.Devices)
}

// required float yaw = 3;
inline bool StatusInfo::has_yaw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StatusInfo::set_has_yaw() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StatusInfo::clear_has_yaw() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StatusInfo::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline float StatusInfo::yaw() const {
  // @@protoc_insertion_point(field_get:RoboProtocol.StatusInfo.yaw)
  return yaw_;
}
inline void StatusInfo::set_yaw(float value) {
  set_has_yaw();
  yaw_ = value;
  // @@protoc_insertion_point(field_set:RoboProtocol.StatusInfo.yaw)
}

// required float pitch = 4;
inline bool StatusInfo::has_pitch() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StatusInfo::set_has_pitch() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StatusInfo::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StatusInfo::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline float StatusInfo::pitch() const {
  // @@protoc_insertion_point(field_get:RoboProtocol.StatusInfo.pitch)
  return pitch_;
}
inline void StatusInfo::set_pitch(float value) {
  set_has_pitch();
  pitch_ = value;
  // @@protoc_insertion_point(field_set:RoboProtocol.StatusInfo.pitch)
}

// required float roll = 5;
inline bool StatusInfo::has_roll() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StatusInfo::set_has_roll() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StatusInfo::clear_has_roll() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StatusInfo::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline float StatusInfo::roll() const {
  // @@protoc_insertion_point(field_get:RoboProtocol.StatusInfo.roll)
  return roll_;
}
inline void StatusInfo::set_roll(float value) {
  set_has_roll();
  roll_ = value;
  // @@protoc_insertion_point(field_set:RoboProtocol.StatusInfo.roll)
}

// required float depth = 6;
inline bool StatusInfo::has_depth() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StatusInfo::set_has_depth() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StatusInfo::clear_has_depth() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StatusInfo::clear_depth() {
  depth_ = 0;
  clear_has_depth();
}
inline float StatusInfo::depth() const {
  // @@protoc_insertion_point(field_get:RoboProtocol.StatusInfo.depth)
  return depth_;
}
inline void StatusInfo::set_depth(float value) {
  set_has_depth();
  depth_ = value;
  // @@protoc_insertion_point(field_set:RoboProtocol.StatusInfo.depth)
}

// required uint32 leak = 7;
inline bool StatusInfo::has_leak() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StatusInfo::set_has_leak() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StatusInfo::clear_has_leak() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StatusInfo::clear_leak() {
  leak_ = 0u;
  clear_has_leak();
}
inline ::google::protobuf::uint32 StatusInfo::leak() const {
  // @@protoc_insertion_point(field_get:RoboProtocol.StatusInfo.leak)
  return leak_;
}
inline void StatusInfo::set_leak(::google::protobuf::uint32 value) {
  set_has_leak();
  leak_ = value;
  // @@protoc_insertion_point(field_set:RoboProtocol.StatusInfo.leak)
}

// required uint32 version = 8;
inline bool StatusInfo::has_version() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StatusInfo::set_has_version() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StatusInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StatusInfo::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 StatusInfo::version() const {
  // @@protoc_insertion_point(field_get:RoboProtocol.StatusInfo.version)
  return version_;
}
inline void StatusInfo::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:RoboProtocol.StatusInfo.version)
}

// required uint32 cameras = 9;
inline bool StatusInfo::has_cameras() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void StatusInfo::set_has_cameras() {
  _has_bits_[0] |= 0x00000100u;
}
inline void StatusInfo::clear_has_cameras() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void StatusInfo::clear_cameras() {
  cameras_ = 0u;
  clear_has_cameras();
}
inline ::google::protobuf::uint32 StatusInfo::cameras() const {
  // @@protoc_insertion_point(field_get:RoboProtocol.StatusInfo.cameras)
  return cameras_;
}
inline void StatusInfo::set_cameras(::google::protobuf::uint32 value) {
  set_has_cameras();
  cameras_ = value;
  // @@protoc_insertion_point(field_set:RoboProtocol.StatusInfo.cameras)
}

// -------------------------------------------------------------------

// Result


// @@protoc_insertion_point(namespace_scope)

}  // namespace RoboProtocol

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::RoboProtocol::Command_Value> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoboProtocol::Command_Value>() {
  return ::RoboProtocol::Command_Value_descriptor();
}
template <> struct is_proto_enum< ::RoboProtocol::Result_Value> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoboProtocol::Result_Value>() {
  return ::RoboProtocol::Result_Value_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_RoboIDE2_2fmur_2dide_2fconnections_2fprotocol_2fRoboPotocol_2eproto__INCLUDED
